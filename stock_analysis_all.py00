import akshare as ak
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from matplotlib.font_manager import FontProperties
from tqdm import tqdm
import time
import os
from datetime import datetime, timedelta

# --- 修复 1: 解决中文字体问题 (修正 Matplotlib 错误) ---
try:
    font_path = '/usr/share/fonts/truetype/wqy/wqy-zenhei.ttc'
    if os.path.exists(font_path):
        fontprop = FontProperties(fname=font_path)
        # 【关键修复】：将字体系列设置为全局参数 (解决 Line2D.set() 错误)
        matplotlib.rcParams['font.family'] = fontprop.get_name() 
        # 仅为文本元素（如标题、图例）保留 fontproperties
        chinese_font = {'fontproperties': fontprop}
        print("中文字体加载成功。")
    else:
        # 尝试设置备用字体
        matplotlib.rcParams['font.sans-serif'] = ['SimHei', 'WenQuanYi Zen Hei', 'Arial Unicode MS']
        chinese_font = {'family': 'sans-serif'}
        print("警告: 无法找到指定中文字体，已尝试设置备用字体。")
        
    matplotlib.rcParams['axes.unicode_minus'] = False
except Exception as e:
    print(f"致命警告: 字体配置失败: {e}，将使用 Matplotlib 默认字体。")
    chinese_font = {}
# ------------------------------------

# 定义常量
DATA_DIR = 'stock_data'
RESULTS_DIR = 'results'
PROGRESS_FILE = 'progress.txt' 

# 创建结果保存目录和数据保存目录
if not os.path.exists(RESULTS_DIR):
    os.makedirs(RESULTS_DIR)
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)

# 获取沪深A股所有股票列表
def get_stock_list():
    """获取沪深A股所有股票列表"""
    print("正在获取股票列表...")
    stock_info_a_code_name_df = ak.stock_info_a_code_name()
    return stock_info_a_code_name_df

# 保存或增量更新单只股票的历史数据
# **[重要修复]** 增加重试次数到 5 次，等待时间增加到 3 秒
def save_and_update_stock_data(stock_code, max_retries=5):
    """
    保存或增量更新单只股票的历史数据，并加入重试机制。
    返回包含最新数据的 DataFrame。
    """
    file_path = os.path.join(DATA_DIR, f"{stock_code}.csv")
    
    start_date_str = "19900101"
    existing_df = pd.DataFrame()
    
    if os.path.exists(file_path):
        try:
            existing_df = pd.read_csv(file_path, parse_dates=['日期'])
            existing_df.sort_values(by='日期', inplace=True)
            
            last_date_obj = existing_df['日期'].iloc[-1]
            last_date_str = last_date_obj.strftime('%Y%m%d')
            
            today_str = datetime.now().strftime('%Y%m%d')
            if last_date_str == today_str:
                 return existing_df

            start_date_obj = last_date_obj + timedelta(days=1)
            start_date_str = start_date_obj.strftime('%Y%m%d')

        except Exception as e:
            print(f"警告: 读取 {stock_code}.csv 失败 ({e})，将尝试重新下载全部数据。")
            
    for attempt in range(max_retries):
        try:
            new_data_df = ak.stock_zh_a_hist(
                symbol=stock_code, 
                period="daily", 
                start_date=start_date_str, 
                end_date=datetime.now().strftime('%Y%m%d'), 
                adjust="qfq"
            )
            
            if new_data_df.empty:
                return existing_df
            
            new_data_df['日期'] = pd.to_datetime(new_data_df['日期'])
            new_data_df.sort_values(by='日期', inplace=True)
            
            if existing_df.empty or start_date_str == "19900101":
                new_data_df.to_csv(file_path, index=False, encoding='utf-8')
                return new_data_df
            else:
                new_data_df = new_data_df[new_data_df['日期'] > existing_df['日期'].iloc[-1]]
                
                if not new_data_df.empty:
                    new_data_df.to_csv(file_path, mode='a', header=False, index=False, encoding='utf-8')
                    return pd.concat([existing_df, new_data_df], ignore_index=True)
                else:
                    return existing_df
            
        except Exception as e:
            error_message = f"下载或更新 {stock_code} 数据失败: {e}"
            if "Remote end closed connection" in str(e) or "Connection aborted" in str(e):
                if attempt < max_retries - 1:
                    print(f"警告: {error_message}。等待 3 秒后重试 (第 {attempt + 2}/{max_retries} 次)...")
                    time.sleep(3)
                else:
                    print(f"致命错误: 下载或更新 {stock_code} 数据失败，已达最大重试次数。")
                    return existing_df
            else:
                print(f"致命错误: {error_message}")
                return existing_df

    return existing_df 

# 计算技术指标 (保持不变)
def calculate_technical_indicators(df):
    """计算各种技术指标"""
    for col in ['开盘', '收盘', '最高', '最低', '成交量']:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
    
    df['MA5'] = df['收盘'].rolling(window=5).mean()
    df['MA10'] = df['收盘'].rolling(window=10).mean()
    df['MA20'] = df['收盘'].rolling(window=20).mean()
    df['MA60'] = df['收盘'].rolling(window=60).mean()
    
    delta = df['收盘'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    
    df['EMA12'] = df['收盘'].ewm(span=12, adjust=False).mean()
    df['EMA26'] = df['收盘'].ewm(span=26, adjust=False).mean()
    df['DIF'] = df['EMA12'] - df['EMA26']
    df['DEA'] = df['DIF'].ewm(span=9, adjust=False).mean()
    df['MACD'] = 2 * (df['DIF'] - df['DEA'])
    
    low_min = df['最低'].rolling(window=9).min()
    high_max = df['最高'].rolling(window=9).max()
    df['RSV'] = 100 * ((df['收盘'] - low_min) / (high_max - low_min + 1e-9))
    df['K'] = df['RSV'].ewm(com=2, adjust=False).mean()
    df['D'] = df['K'].ewm(com=2, adjust=False).mean()
    df['J'] = 3 * df['K'] - 2 * df['D']
    
    return df

# 分析股票的买入信号 (保持不变)
def analyze_buy_signals(df, stock_code, stock_name):
    """分析股票的买入信号"""
    signals = []
    score = 0
    
    if len(df) < 60:
        return {"code": stock_code, "name": stock_name, "signals": ["数据不足"], "score": 0}
    
    required_cols = ['收盘', 'MA5', 'MA20', 'RSI', 'MACD', 'DIF', 'DEA', 'K', 'D', 'J']
    for col in required_cols:
        if col not in df.columns or df[col].isnull().all():
            return {"code": stock_code, "name": stock_name, "signals": ["数据计算错误"], "score": 0}
    
    try:
        if df['MA5'].iloc[-1] > df['MA20'].iloc[-1] and df['MA5'].iloc[-2] <= df['MA20'].iloc[-2]:
            signals.append("MA金叉形成")
            score += 20
        
        current_rsi = df['RSI'].iloc[-1]
        if 30 <= current_rsi <= 50:
            signals.append(f"RSI值为{current_rsi:.2f}，处于低位回升阶段")
            score += 15
        elif current_rsi < 30:
            signals.append(f"RSI值为{current_rsi:.2f}，股票可能超卖")
            score += 10
        
        if df['DIF'].iloc[-1] > df['DEA'].iloc[-1] and df['DIF'].iloc[-2] <= df['DEA'].iloc[-2]:
            signals.append("MACD金叉形成")
            score += 20
        
        if df['K'].iloc[-1] > df['D'].iloc[-1] and df['K'].iloc[-2] <= df['D'].iloc[-2]:
            if df['K'].iloc[-1] < 50:
                signals.append("KDJ低位金叉")
                score += 15
            else:
                signals.append("KDJ金叉")
                score += 10
        
        avg_volume = df['成交量'].iloc[-6:-1].mean()
        current_volume = df['成交量'].iloc[-1]
        price_change = (df['收盘'].iloc[-1] / df['收盘'].iloc[-2] - 1) * 100
        
        if current_volume > 1.5 * avg_volume and price_change > 0:
            signals.append(f"放量上涨: 量比{current_volume/avg_volume:.2f}, 涨幅{price_change:.2f}%")
            score += 15
        
        recent_high = df['最高'].iloc[-20:-1].max()
        if df['收盘'].iloc[-1] > recent_high:
            signals.append("突破20日前高")
            score += 15
            
    except Exception as e:
        signals.append(f"分析过程出错: {str(e)}")
        score = 0
    
    return {
        "code": stock_code,
        "name": stock_name,
        "signals": signals,
        "score": score
    }

# 获取并分析单只股票数据 (从本地文件获取或更新)
def analyze_single_stock(stock_code, stock_name):
    """从本地文件加载或更新数据，并进行分析"""
    try:
        df = save_and_update_stock_data(stock_code)
        
        if df.empty:
            return {
                "code": stock_code,
                "name": stock_name,
                "signals": ["数据获取失败/为空"],
                "score": 0
            }

        df = calculate_technical_indicators(df)
        result = analyze_buy_signals(df, stock_code, stock_name)
        
        if result['score'] >= 30:
            save_analysis_chart(df, stock_code, stock_name, result)
        
        return result
    
    except Exception as e:
        return {
            "code": stock_code,
            "name": stock_name,
            "signals": [f"分析失败: {str(e)}"],
            "score": 0
        }

# 保存分析图表 (修正 Matplotlib 错误)
def save_analysis_chart(df, stock_code, stock_name, result):
    """生成并保存股票分析图表"""
    try:
        plt.figure(figsize=(15, 12))
        
        plt.subplot(3, 1, 1)
        if df.index.name != '日期' and '日期' in df.columns:
            df = df.set_index('日期') 
            
        df_plot = df.iloc[-60:]
            
        # 【修复点】：移除 plt.plot 中的 **chinese_font
        plt.plot(df_plot.index, df_plot['收盘'], label='收盘价')
        plt.plot(df_plot.index, df_plot['MA5'], label='MA5')
        plt.plot(df_plot.index, df_plot['MA20'], label='MA20')
        plt.plot(df_plot.index, df_plot['MA60'], label='MA60')
        
        plt.title(f'{stock_code} {stock_name} - 股价走势与技术指标', **chinese_font)
        plt.legend(**chinese_font)
        plt.grid(True)
        
        plt.subplot(3, 1, 2)
        # 【修复点】：移除 plt.plot/plt.bar 中的 **chinese_font
        plt.plot(df_plot.index, df_plot['DIF'], label='DIF')
        plt.plot(df_plot.index, df_plot['DEA'], label='DEA')
        plt.bar(df_plot.index, df_plot['MACD'], label='MACD', color=['r' if x > 0 else 'g' for x in df_plot['MACD']])
        plt.title('MACD指标', **chinese_font)
        plt.legend(**chinese_font)
        plt.grid(True)
        
        plt.subplot(3, 1, 3)
        # 【修复点】：移除 plt.plot 中的 **chinese_font
        plt.plot(df_plot.index, df_plot['K'], label='K')
        plt.plot(df_plot.index, df_plot['D'], label='D')
        plt.plot(df_plot.index, df_plot['J'], label='J')
        plt.plot(df_plot.index, df_plot['RSI'], label='RSI', color='purple')
        plt.axhline(y=80, color='r', linestyle='--')
        plt.axhline(y=20, color='g', linestyle='--')
        plt.title('KDJ与RSI指标', **chinese_font)
        plt.legend(**chinese_font)
        plt.grid(True)
        
        plt.tight_layout()
        file_path = f'{RESULTS_DIR}/{stock_code}_{stock_name}_analysis.png'
        plt.savefig(file_path)
        plt.close()
        
        result['chart_path'] = file_path
    except Exception as e:
        print(f"生成图表出错({stock_code}): {str(e)}")
        if 'chart_path' in result:
             del result['chart_path']

# 主函数
def main():
    # ----------------------------------------
    # 1. 检查和加载进度
    # ----------------------------------------
    start_index = 0
    if os.path.exists(PROGRESS_FILE):
        with open(PROGRESS_FILE, 'r') as f:
            try:
                start_index = int(f.read().strip())
                print(f"检测到上次进度，将从第 {start_index + 1} 只股票开始分析。")
            except ValueError:
                os.remove(PROGRESS_FILE)
                print("进度文件损坏，将从头开始分析。")
                start_index = 0
    
    stock_list = get_stock_list()
    
    # 确保列名标准化
    is_renamed = False
    col_mapping = {
        'code': '代码', 'name': '名称', 
        'symbol': '代码'
    }
    for old, new in col_mapping.items():
        if old in stock_list.columns and new not in stock_list.columns:
            stock_list = stock_list.rename(columns={old: new}, inplace=False)
            is_renamed = True
    
    if '代码' not in stock_list.columns or '名称' not in stock_list.columns:
        print("致命错误：无法识别股票列表中的股票代码或名称列名。")
        print("当前的列名是：", stock_list.columns.tolist())
        return
    
    if is_renamed:
        print("成功重命名股票列表列名以匹配脚本逻辑。")
        
    # ----------------------------------------
    # 2. 排除 ST 股票
    # ----------------------------------------
    initial_count = len(stock_list)
    # 排除名称中含有 *ST, ST 或 退 的股票
    stock_list = stock_list[~stock_list['名称'].str.lower().str.contains(r'[s\*]t|退', na=False)]
    print(f"已排除 {initial_count - len(stock_list)} 只 ST/退市 股票。")
    
    total_stocks = len(stock_list)
    
    # ----------------------------------------
    # 3. 设置分段处理范围
    # ----------------------------------------
    BATCH_SIZE = 20  # <-- 【修复点】：限制批次大小为 20，用于调试
    
    END_INDEX = min(start_index + BATCH_SIZE, total_stocks)
    
    if start_index >= total_stocks:
        print("所有股票已分析完毕。任务结束。")
        if os.path.exists(PROGRESS_FILE):
             os.remove(PROGRESS_FILE)
        return

    print(f"共获取到 {total_stocks} 只股票 (排除ST后)")
    print(f"本次任务范围: 分析 {start_index + 1} 到 {END_INDEX} 只股票。")
    
    current_batch = stock_list.iloc[start_index:END_INDEX]
    
    results = []
    
    for idx, row in tqdm(current_batch.iterrows(), total=len(current_batch), desc="分析进度"):
        stock_code = row['代码']
        stock_name = row['名称']
        
        result = analyze_single_stock(stock_code, stock_name)
        
        if result['score'] >= 30:
            results.append(result)
        
        # 脚本内部的请求间隔
        time.sleep(0.5)
    
    # ----------------------------------------
    # 4. 结果处理和进度保存
    # ----------------------------------------
    
    if results:
        csv_data = []
        for result in results:
            signals_str = '; '.join(result['signals'])
            row = {
                '股票代码': result['code'],
                '股票名称': result['name'],
                '买入信号': signals_str,
                '评分': result['score'],
                '图表路径': result.get('chart_path', '')
            }
            csv_data.append(row)
        
        df_result = pd.DataFrame(csv_data)
        df_result.to_csv(f'{RESULTS_DIR}/buy_signals_{start_index}_to_{END_INDEX}.csv', index=False, encoding='utf-8-sig')
        print(f"批次结果已保存到 {RESULTS_DIR}/buy_signals_{start_index}_to_{END_INDEX}.csv")

    
    next_start_index = END_INDEX
    
    if next_start_index < total_stocks:
        with open(PROGRESS_FILE, 'w') as f:
            f.write(str(next_start_index))
        print(f"本次任务完成。进度已保存，下次将从 {next_start_index + 1} 只股票继续。")
        
        # 退出码 99 通知工作流重启
        exit(99) 
    else:
        if os.path.exists(PROGRESS_FILE):
             os.remove(PROGRESS_FILE)
        print("所有股票已分析完毕。进度文件已清除。")
        # 退出码 0 通知工作流完成
        exit(0)

if __name__ == "__main__":
    main()
